{%@comment

This is an article published on javax0.wordpress.com


%}
{%@import https://raw.githubusercontent.com/central7/wordpress/wp.jim%}
{%@snip:collect src/test/java/%}\
{%#reflow
Unit testing is usually not black-box testing.
It is debatable if it ought to be or not.
Practice shows that it rarely is.
When we equip the tested unit with different mocks, we play around with the implementation and not the defined functionality that a black-box test should only deal with.

After setting up and injecting the mock objects, we invoke the tested methods, and these methods are usually public.
In other words, the invocation of the tested system is more like a black-box test.
You can say that the test setup is not a black-box test but the actual test is.

The advantage of black-box testing is that it does not need to change if the internal working of the tested module changes.
If the functionality changes, it is another story.
It is easier to refactor, optimize, simplify, beautify your code if there are clean unit tests that do not depend on the implementation.
If the unit tests depend to the implementation, then you cannot reliably refactor your code.
As soon as you change the implementation, the test has to follow the change.

I do not like when the unit test cannot be black-box, but there are cases, when it is unavoidable.
A special and frequent case is when we want to test a private method.
If you want to, or even God forgive, have to test a private method it is a code smell.
It is possible the method is simple and the coverage of its functionality can be achieved invoking only the public API of the tested unit.
In that case you do not have to test the private method and if you do not have to then you must not want.

Another possibility is that that the private method so complex that it deserves its own test.
In that case the functionality deserves a separate utility class.

Still there is a third possibility.
It is that after all the contemplating we decide that the private method remains inside the unit and we want to test it.

It is a small, insignificant problem that it cannot be invoked from outside and the test is inevitably outside of the unit.
This is when some developer remove the private modifier changing the access level from private to test private.

No kidding!
After more than 500 technical interviews of the past ten years I have heard a lot of things.
I regret that I did not start these.
One of these nice things was that I heard a few times: "test private" as a terminology instead of package private.
Two or three candidates out of the 500 said that the accessibility is test private when there is no access modifier in front of the class member.
It meas, they said that the member can also be accessible from the unit tests.
From other classes in the same package?
Not so sure.

What this story suggests is that many developers struggle to test private methods.
I have also seen this in many other projects.

What I do not like in this approach is that we weaken the access protection of a class member in order to ease testing.

A different approach is when the tests use reflection to access the class members.
There are two issues with this approach.
One is the suboptimal performance, the other is the bloated code.
The fact that the access to the class members via reflection is slower than the direct access is usually not significant.
We are talking about test.
If the test execution needs significant time then the tests are wrong or the project is large or has some special testing need.
Even in thee cases the reason for the slow speed is usually not the reflective access.

The bloated code on the other hand hinders the readability.
It is also cumbersome to write every time things like
%}

{%javaCode
Field f = sut.getClass().getDeclaredField("counter");
f.setAccessible(true);
f.set(sut, z);
%}
{%#reflow
when we want to set a private field, or
%}
{%javaCode
Method m = sut.getClass().getDeclaredMethod("increment");
m.setAccessible(true);
m.invoke(sut);
%}
{%#reflow
when we want to invoke a private method.
The maintenance of sucvh tests is also questionable.
If the name of the method or field changes the test has to follow.
There is no big risk forgetting because the test will fail, but still, it is a manual editing functionality.
Renaming is supported by most of the IDEs and whenever I rename a method or field then all the references to it are also renamed.
Not, when the reference is part of a string.

There is no real solution to this issue, except when you write code that does not need the testing of private methods and fields.
Still there are approaches that have advantages.

One approach is to declare a `private` `static` delegating inner class that has the same name as the tested class.
This class has to implement the same methods as the original tested class and these implementations should delegate to the original methods.
The class also has to implement setters and getters to all the fields.

If we instantiate this class instead of the original one then we can invoke any method or set any field without reflective access in the test code.
The reflective access is hidden in the inner class.

The reason to name the class with the same simple name as the tested class is that this way the tests do not need to change.
If a test has a code that instantiated the tested class calling `new Sut()` and now we start to have an innner class named `Sut` then the constructor all of a sudden will refer to the inner class.

Let's see an example.
The following class is a simple example that has one public method and a private one.
The complexity of the methods barely reaches the level that would rectify extensive testing, but this makes it good for demonstration purposes.

{%#snip:define SUT={%javaCode {%#killLines {%@define pattern=^\s*/?\*/?%}{%@snip SystemUnderTest%}%}%}%}%}
{%@snip SUT
[sourcecode language="java"]
public class SystemUnderTest {

    private int counter = 0;

    public int count(int z) {
        while (z > 0) {
            z--;
            increment();
        }
        return counter;
    }

    private void increment(){
            counter++;
    }

}
[/sourcecode]
%}

This file along with the other samples can be found in full at
https://github.com/verhas/javageci/tree/1.6.1/javageci-jamal/src/test/java/javax0/geci/jamal/sample

The test itself is also very simple:

{%#snip:define TESTMANUAL={%javaCode {%#trimLines
{%@snip testCounter%}%}%}%}
{%@snip TESTMANUAL
[sourcecode language="java"]
@Test
void testCounter() throws Exception {
    final var sut = new SystemUnderTest();
    sut.setCounter(0);
    sut.increment();
    Assertions.assertEquals(1, sut.getCounter());
}
[/sourcecode]
%}

{%#reflow

The only problem with this solution that the system under test does not contain the setter and the method `increment()` is private.
The code, as it is now does not compile.
We have to provide an implementation of the delegating `static` inner class named `SystemUnderTest`.

The following code shows an implementation of this class, which was created manually.
%}

{%#snip:define SUTPROXYMANUAL={%javaCode {%#trimLines
{%@snip SystemUnderTestManual%}%}%}%}
{%@snip SUTPROXYMANUAL
[sourcecode language="java"]
private static class SystemUnderTest {
    private javax0.geci.jamal.sample.SystemUnderTest sut = new javax0.geci.jamal.sample.SystemUnderTest();

    private void setCounter(int z) throws NoSuchFieldException, IllegalAccessException {
        Field f = sut.getClass().getDeclaredField("counter");
        f.setAccessible(true);
        f.set(sut, z);
    }

    private int getCounter() throws NoSuchFieldException, IllegalAccessException {
        Field f = sut.getClass().getDeclaredField("counter");
        f.setAccessible(true);
        return (int) f.get(sut);
    }

    private void increment() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
        Method m = sut.getClass().getDeclaredMethod("increment");
        m.setAccessible(true);
        m.invoke(sut);
    }

    private int count(int z) {
        return sut.count(z);
    }
}
[/sourcecode]
%}

{%#reflow

This is already an achievement, because we could separate the messy reflective access from the test code.
The test, this way, is more readable.
Since we cannot avoid the reflective code, it will not get better than this as per the readability.
The other issue, maintainability, however can still be imrpoved.

Creating the delegating inner class is fairly straightforward.
It does not really need a lot of innovation.
If you specify the task precisely any cheeply hired junior could create the inner class.
As a matter of fact it is so simple that it can even be created by a program.
It doe not need human brain.

If you tried to write a Java progrram from scratch that generates this code it would be, ... well, not simple.
Fortunately (ha ha ha) we have Java::Geci and even more we have the Jamal module.
Jav::Geci is a code generation framework, that you can use to generate Java code.
The framework contains readily available code generators, but it is also open and pluggable providing an clean API for new code generators.
It does all the task, which are needed for most of the code generators and lets the code generator program to focus on its core business.

Code generation.

For simpler application, when the code generation is straightforward and does not need a lot of algorithm implementation the module Jamal can be used.
Jamal is a text based templating language, which can be extended with Java classes implementing macros.
The Java::Geci Jamal module includes a code generator that parses the source files and looks for code that has the following structure:

{%javaCode
/*!jamal

<<TEMPLATE>>

*/

<<CODE HERE>>
//__END__
%}

When it sees one then it evaluates the code that is written on the lines `<<TEMPLATE>>` using Jamal and then it replaces the lines of `<<CODE HERE>>` with the result.
It generates code and if there was a generated code, but is stale then it updates the code.

The code generation runs during the test execution time, which has advantages and disadvantages.

One disadvantage is, that the empty code, or stale code should also compile.
The compilation should not depend on the up-to-date-ness of the generated code.
In practice we usually (well, not usually, rather always) can cope with it.

The advantage is that the code generation can access to the Java code structures via reflection.
That way, for example, the code generators can get a list of all declared fields, or methods and can generate some delegating methods for them.

The Jamal module contains Java classes implementing macros that can just do that.
The fact that you can express the generation of the unit test delegating inner class as Jamal macros show the power of the tool.
On the other hand, I have to make a note, that this task is somewhere the edge of the complexity that the tool can handle.
Nevertheless, I decided to use this task as a sample, because generating setter and getters is boring.
I also want to avoid lazy readers asking me why to have another setter/getter generator as it happened at some conferences where I talked about Java::Geci.
Setter and getter generator is not a good example, as it does not show you the advantage.
You can do that with the IDE, or using Lombok or some other tool.
Perhaps after reading this article you can give a try and implement the setter/getter generation using Jamal just for fun and to practice.

{%@define classFormat=`$simpleName`%}
The previous code snippets were from the class {%@java:class javax0.geci.jamal.sample.ManualTestSystemUnderTest%}.
This class contains the manually created delegating inner class for demonstration purposes.
The other testing class, {%@java:class javax0.geci.jamal.sample.GeneratedTestSystemUnderTest%} contains the generated sample code.
We will look at the code in this file and how it gets automatically generated.

Before looking at the code, however, I have to make two notes:

* The example code uses a simplified version of the macros. These macros do not cover all the possible cases.

* On the other hand the code includes all the macros in the source file.
Professional code does not need to have these macros in the source.
All they need is an import from a resource file and then the invocation of a single macro.
Two lines.
The macros generating the delegating inner class are defined in a resource file.
It is written once, you do not need to write them all the time.
I will show you at the and of this article how it is invoked.


%}




{%@snip:update%}
